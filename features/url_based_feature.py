# -*- coding: utf-8 -*-
"""url_based_feature.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IDmtCLK9flKKcp_IzG68Lkr3h-g0VE01
"""

# pip install python-whois

import re
from urllib.parse import urlparse
import whois
import socket
from concurrent.futures import ThreadPoolExecutor, as_completed

# URLURL_Length : 75 초과 피싱 / 54 이상 75 이하 의심 / 54 미만 정상
def check_url_length(url):
    if len(url) < 54 :
        return -1
    elif len(url) >= 54 and len(url) <= 75 :
        return 0
    else :
        return 1

# port
# def scan_port(ip, port, standard_ports):
#     with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
#         sock.settimeout(1)  # 타임아웃 설정
#         try:
#             result = sock.connect_ex((ip, port))
#             if result == 0:  # 포트가 열려 있는 경우
#                 if port not in standard_ports:
#                     return 1  # 비표준 포트가 열려 있으면 피싱
#         except (socket.timeout, socket.error):
#             return -1  # 오류가 발생한 경우, 다음 포트로 이동
#     return 0  # 포트가 닫혀 있거나 정상 포트만 열려 있는 경우

# def port_scan(domain):
#     standard_ports = {80, 443}
#     risky_ports = [21, 22, 445, 1433, 1521, 3306, 3389]

#     try:
#         ip = socket.gethostbyname(domain)
#     except socket.gaierror:
#         return 0  # 도메인 이름을 IP로 변환할 수 없을 때, 의

#     ports_to_scan = list(standard_ports.union(risky_ports))

#     with ThreadPoolExecutor(max_workers=len(ports_to_scan)) as executor:
#         futures = [executor.submit(scan_port, ip, port, standard_ports) for port in ports_to_scan]
#         for future in as_completed(futures):
#             result = future.result()
#             if result == 1:
#                 return 1  # 비표준 포트가 열려 있으면 피싱

#     return -1  # 모든 비표준 포트가 닫혀 있고 정상 포트만 열려 있을 경우

def port_scan(domain):
    try:
        ip = socket.gethostbyname(domain)
    except socket.gaierror:
        return -1  # 도메인 이름을 IP로 변환할 수 없을 때

    socket.setdefaulttimeout(2)  # 타임아웃 설정

    # 표준 포트와 비표준 포트 목록
    standard_ports = [80, 443]
    risky_ports = [21, 22, 23, 445, 1433, 1521, 3306, 3389]
    all_ports = standard_ports + risky_ports

    standard_port_open = False

    for port in all_ports:
        with socket.socket() as s:
            try:
                s.connect((ip, port))
                if port in standard_ports:
                    standard_port_open = True  # 표준 포트가 열려 있음
                else:
                    return 1  # 비표준 포트가 열려 있으면 피싱 가능성 있음
            except (socket.timeout, socket.error):
                continue

    if standard_port_open:
        return -1  # 표준 포트만 열려 있는 경우 정상
    else:
        return 0  # 모든 포트가 닫혀 있는 경우 의심

# having_At_Symbol
def check_at_symbol(url):
    if "@" in url:
        return 1
    return 0

# double_slash_redirecting
def check_double_slash_redirecting(url):
    if url.startswith("http://") and url.find("//", 7) > 7:
        return 1
    if url.startswith("https://") and url.find("//", 8) > 8:
        return 1
    return 0

# Prefix_Suffix
def check_prefix_suffix(url):
    domain = urlparse(url).netloc
    if '-' in domain:
        return 1
    return 0

# Abnormal_URL
def check_abnormal_url(url):
    domain = urlparse(url).netloc

    try:
        # WHOIS 정보 조회
        w = whois.whois(domain)

        if not w.domain_name or not w.creation_date:
            return 1
        else:
            return -1
    except Exception as e:
        # WHOIS 조회 실패 시 피싱으로 간주
        return 1

def test_features():
    test_urls = [
        "http://www.crestonwood.com/router.php",  # 정상 URL
        "https://support-appleld.com.secureupdate.duilawyeryork.com/ap/89e6a3b4b063b8d/?cmd=_update&dispatch=89e6a3b4b063b8d1b&locale=_",  # 긴 URL
        "http://mcsquareintl.com:32000/mail/expiredpass.html", # 포트 스캔
        "https://www.centromusicalpaternense.es:443/wp-includes/css", # 포트스캔2
        "http://www.inbioma.pe/rechnung-376440790464490488&amp;cgi3-viewkontakt-376440790464490488-007acctpagetype-376440790464490488=4674720-&amp;info@s-und-s-shop.de.html",  # '@' 기호 포함
        "http://maanprofessionals.nl//index.html",  # double slash 포함
        "http://appleid.apple.com-app.es/",  # '-' 포함
        "http://www.history.com/topics/american-civil-war/gettysburg-address",  # 정상 도메인
        "http://izvilagkft.hu/wp-content/languages/.../redirect/com.htm",  # 비정상 도메인
    ]

    for url in test_urls:
        print(f"테스트 URL: {url}")

        # 결과 저장
        phishing_reasons = []

        # 각 피처 검사
        if check_url_length(url) == 1:
            phishing_reasons.append("URL Length")

        if port_scan(urlparse(url).netloc) == 1:
            phishing_reasons.append("Port Scan")

        if check_at_symbol(url) == 1:
            phishing_reasons.append("'@' Symbol")

        if check_double_slash_redirecting(url) == 1:
            phishing_reasons.append("Double Slash Redirecting")

        if check_prefix_suffix(url) == 1:
            phishing_reasons.append("Prefix-Suffix")

        if check_abnormal_url(url) == 1:
            phishing_reasons.append("Abnormal URL")

        # 결과 출력
        if phishing_reasons:
            print("  Result: 피싱")
            print("  Reasons: " + ", ".join(phishing_reasons))
        else:
            print("  Result: 정상")

        print("-" * 50)


if __name__ == "__main__":
    test_features()