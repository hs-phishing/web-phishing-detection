# -*- coding: utf-8 -*-
"""merge_feature.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WrrtzMWX-RBm6Qhy9EqFDP22ei9zIvwv
"""

import pandas as pd
import concurrent.futures

# 테스트 데이터 셋
df = pd.read_csv('test_dataset.csv')

# 라이브러리 임포트
import requests
import regex
import ipaddress
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
from features import url_based_feature as ubf
from features import content_based_features as cbf
from features import domainver1 as dbf
from features import short_url_features as suf

def apply(df, func_name, col_name):
    results = []
    
    # 단축 url 판별
    for idx, url in enumerate(df['url']):
        print(f"Processing {idx + 1}/{len(df)}: {url}")  # 현재 몇 번째 URL을 처리 중인지 출력

        # 단축 URL 판별 및 복원 / 문제점 -> 복원 실패 시의 방향이 너무 많음
        expanded_url, status = suf.check_url(url)  
        
        # 복원된 URL 또는 원래 URL을 피처 함수에 전달
        if status == 1:  # 1 : 복원에 성공한 경우
            result = func_name(expanded_url)  # 복원된 URL을 사용
        else:           # -1 : 복원에 실패한 경우
            result = func_name(url)  # 복원되지 않았으면 원래 URL을 사용 -> 변경 필요

        results.append(result)  # 결과 리스트에 추가

    df[col_name] = results  # 결과를 새로운 컬럼에 추가
    df.reset_index(drop=True, inplace=True)  # 인덱스 재설정

    if col_name not in df.columns:
        print(f"피처 '{col_name}'이 데이터프레임에 존재하지 않습니다.")

apply(df, cbf.use_right_click, 'RightClick')
apply(df, cbf.popup_window_text, 'popUpWidnow')
apply(df, cbf.iFrame_redirection, 'Iframe')
apply(df, cbf.using_ip, 'having_IPhaving_IP_Address')
apply(df, cbf.check_favicon, 'Favicon')
apply(df, cbf.check_request_url, 'Request_URL')
apply(df, cbf.check_url_of_anchor, 'URL_of_Anchor')
apply(df, cbf.has_meta_tags, 'Links_in_tags')
apply(df, cbf.check_sfh, 'SFH')
apply(df, cbf.check_submit_email, 'Submitting_to_email')
apply(df, cbf.check_redirect_count, 'Redirect')
apply(df, cbf.check_onmouseover_change, 'on_mouseover')
apply(df, ubf.check_url_length, 'URLURL_Length')
apply(df, ubf.scan_port, 'port') # 확인필요
apply(df, ubf.check_at_symbol, 'having_At_Symbol')
apply(df, ubf.check_double_slash_redirecting, 'double_slash_redirecting')
apply(df, ubf.check_prefix_suffix, 'Prefix_Suffix')
apply(df, ubf.check_abnormal_url, ' Abnormal_URL')
apply(df, dbf.google_index, ' Google_Index')
apply(df, dbf.domain_age, ' age_of_domain')
apply(df, dbf.dns_record, ' DNSRecord')
apply(df, dbf.domain_registration_period, ' Domain_registeration_length')
apply(df, dbf.ssl_certificate_status, ' SSLfinal_State')
apply(df, dbf.having_sub_domain, ' having_Sub_Domain')
apply(df, dbf.https_token, ' HTTPS_token')

# 결과를 CSV 파일로 저장
df.to_csv('merge_test_dataset.csv', index=False)
